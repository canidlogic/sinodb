#!/usr/bin/env perl
use strict;
use warnings;

=head1 NAME

xrefgroup.pl - Generate crossreference groups.

=head1 SYNOPSIS

  ./xrefgroup.pl < xref.map

=head1 DESCRIPTION

Takes as input a crossreference map generated by the varref.pl script in
C<map> invocation mode.  Generates a list of word groups where each line
is a group with all line numbers of component records listed, and sorted
in order such that "weightier" records in terms of number of connections
within the group are earlier in the group.

=cut

# =========
# Constants
# =========

# The maximum recursive depth for resolving groups.
#
my $MAX_DEPTH = 64;

# ===============
# Local functions
# ===============

# group_merge(\%net, $a, $b)
#
# Go through the group assignments hash reference given by net and
# replace any group assignments to b with a group assignment to a,
# effectively merging group b into group a.
#
sub group_merge {
  # Check and get parameters
  ($#_ == 2) or die "Wrong number of parameters, stopped";
  
  my $rn = shift;
  my $a  = shift;
  my $b  = shift;
  
  (ref($rn) eq 'HASH') or die "Wrong parameter type, stopped";
  (not ref($a)) or die "Wrong parameter type, stopped";
  (not ref($b)) or die "Wrong parameter type, stopped";
  
  (int($a) == $a) or die "Wrong parameter type, stopped";
  (int($b) == $b) or die "Wrong parameter type, stopped";
  
  $a = int($a);
  $b = int($b);
  
  (($a > 0) and ($b > 0)) or die "Wrong parameter type, stopped";
  
  # Go through and update group assignments
  for my $key (keys %$rn) {
    if ($rn->{$key} == $b) {
      $rn->{$key} = $a;
    }
  }
}

# group_weight(\%xh, \@ga, \@wm, $i, $depth)
#
# Recursively update the weight map of a group by adding one to the
# weight of a given element within the group and all other elements it
# connects to.
#
# xh is a reference to the crossreference hash, ga is a reference to the
# array storing the line numbers of the group members in any order, wm
# is a reference to the weight array, which has the same length as the
# group array, i is the index of the element to add a weight to, and
# depth is the recursive depth.  The recursive depth may go up to
# MAX_DEPTH before a fatal error occurs.
#
sub group_weight {
  # Check and get parameters
  ($#_ == 4) or die "Wrong number of parameters, stopped";
  
  my $xn    = shift;
  my $ga    = shift;
  my $wm    = shift;
  my $i     = shift;
  my $depth = shift;
  
  (ref($xn) eq 'HASH') or die "Wrong parameter type, stopped";
  (ref($ga) eq 'ARRAY') or die "Wrong parameter type, stopped";
  (ref($wm) eq 'ARRAY') or die "Wrong parameter type, stopped";
  (not ref($i)) or die "Wrong parameter type, stopped";
  (not ref($depth)) or die "Wrong parameter type, stopped";
  
  (int($i) == $i) or die "Wrong parameter type, stopped";
  (int($depth) == $depth) or die "Wrong parameter type, stopped";
  
  $i     = int($i);
  $depth = int($depth);
  
  (($i >= 0) and ($depth >= 0)) or die "Wrong parameter type, stopped";
  (scalar(@$ga) == scalar(@$wm)) or die "Array mismatch, stopped";
  ($i < scalar(@$ga)) or die "Index out of range, stopped";
  
  # Stop if maximum depth has been reached
  ($depth < $MAX_DEPTH) or die "Recursive depth exceeded, stopped";
  
  # Increment the weight of the given element
  $wm->[$i] = $wm->[$i] + 1;
  
  # Recursively increment the weight of all connected elements
  if (defined $xn->{"$ga->[$i]"}) {
    for my $e (@{$xn->{"$ga->[$i]"}}) {
      # Find the index of this element in the group array
      my $j = undef;
      for(my $k = 0; $k < scalar(@$ga); $k++) {
        if ($ga->[$k] == $e) {
          $j = $k;
          last;
        }
      }
      (defined $j) or die "Reference out of group, stopped";
      
      # Recursively add weight to connection
      group_weight($xn, $ga, $wm, $j, $depth + 1);
    }
  }
}

# group_set(\%xh, \%net, $key, $depth, $group)
#
# Recursively set a given node and all nodes it connects to with a given
# group number.
#
# xh is a reference to the crossreference hash, net is a reference to
# the hash storing group number assignments, key is the key of the node
# to set a group for, depth is the current recursive depth, and group is
# the group number to set.  The recursive depth may go up to MAX_DEPTH
# before a fatal error occurs.
#
sub group_set {
  # Check and get parameters
  ($#_ == 4) or die "Wrong number of parameters, stopped";
  
  my $xn    = shift;
  my $rn    = shift;
  my $key   = shift;
  my $depth = shift;
  my $group = shift;
  
  (ref($xn) eq 'HASH') or die "Wrong parameter type, stopped";
  (ref($rn) eq 'HASH') or die "Wrong parameter type, stopped";
  (not ref($key)) or die "Wrong parameter type, stopped";
  (not ref($depth)) or die "Wrong parameter type, stopped";
  (not ref($group)) or die "Wrong parameter type, stopped";
  
  (int($key) == $key) or die "Wrong parameter type, stopped";
  (int($depth) == $depth) or die "Wrong parameter type, stopped";
  (int($group) == $group) or die "Wrong parameter type, stopped";
  
  $key = int($key);
  $depth = int($depth);
  $group = int($group);
  
  (($key > 0) and ($depth >= 0) and ($group > 0)) or
    die "Wrong parameter type, stopped";
  (defined($rn->{"$key"})) or die "Invalid key, stopped";
  
  # Stop if maximum depth has been reached
  ($depth < $MAX_DEPTH) or die "Recursive depth exceeded, stopped";
  
  # Set the current node's group number
  $rn->{"$key"} = $group;
  
  # Recursively set the group numbers of everything this key is
  # connected to
  if (defined $xn->{"$key"}) {
    for my $k (@{$xn->{"$key"}}) {
      group_set($xn, $rn, $k, $depth + 1, $group);
    }
  }
}

# group_search(\%xh, \%net, $key, $depth)
#
# Recursively check whether a given node identified by a key is in any
# way connected to a node that already has a group number.  Returns a
# list of all group numbers this key is connected to, or an empty list
# if not connected to any group numbers.
#
# xh is a reference to the crossreference hash, net is a reference to
# the hash storing group number assignments, key is the key of the node
# to find a group for, and depth is the current search depth.  The
# recursive depth may go up to MAX_DEPTH before a fatal error occurs.
#
sub group_search {
  # Check and get parameters
  ($#_ == 3) or die "Wrong number of parameters, stopped";
  
  my $xn    = shift;
  my $rn    = shift;
  my $key   = shift;
  my $depth = shift;
  
  (ref($xn) eq 'HASH') or die "Wrong parameter type, stopped";
  (ref($rn) eq 'HASH') or die "Wrong parameter type, stopped";
  (not ref($key)) or die "Wrong parameter type, stopped";
  (not ref($depth)) or die "Wrong parameter type, stopped";
  
  (int($key) == $key) or die "Wrong parameter type, stopped";
  (int($depth) == $depth) or die "Wrong parameter type, stopped";
  
  $key = int($key);
  $depth = int($depth);
  
  (($key > 0) and ($depth >= 0)) or die "Wrong parameter type, stopped";
  (defined($rn->{"$key"})) or die "Invalid key, stopped";
  
  # Stop if maximum depth has been reached
  ($depth < $MAX_DEPTH) or die "Recursive depth exceeded, stopped";
  
  # If this key already has a group number, return that by itself
  if ($rn->{"$key"} > 0) {
    return ($rn->{"$key"});
  }
  
  # Otherwise, recursively get the group numbers of everything this key
  # is connected to
  my %groups;
  if (defined $xn->{"$key"}) {
    for my $k (@{$xn->{"$key"}}) {
      my @scan = group_search($xn, $rn, $k, $depth + 1);
      for my $s (@scan) {
        $groups{"$s"} = 1;
      }
    }
  }
  
  # Return a sorted list of all the groups we found
  return map(int, sort { int($a) <=> int($b) } keys %groups);
}

# ==================
# Program entrypoint
# ==================

# Check that no arguments
#
($#ARGV < 0) or die "Not expecting program arguments, stopped";

# Build a hash reference that maps source line numbers to arrays of
# target line numbers using the input crossreference map
#
my %xh;
while(not eof(STDIN)) {
  # Read a line
  my $ltext;
  defined($ltext = <STDIN>) or die "I/O error, stopped";
  
  # Drop line break
  chomp $ltext;
  
  # Skip if blank
  (not ($ltext =~ /\A\s*\z/)) or next;
  
  # Parse record line
  ($ltext =~ /\A([1-9][0-9]*): ([0-9 ]+)\z/) or
    die "Invalid crossreference record, stopped";
  
  my $src = int($1);
  my $ar  = $2;
  
  # Parse the target array
  $ar =~ s/\A\s+//;
  $ar =~ s/\s+\z//;
  (length($ar) > 0) or die "Invalid crossreference record, stopped";
  
  my @targets = map(int, split ' ', $ar);
  ($#targets >= 0) or die "Unexpected";
  
  # Verify that targets in ascending order
  for(my $i = 1; $i <= $#targets; $i++) {
    ($targets[$i] > $targets[$i - 1]) or
      die "Invalid crossreference record, stopped";
  }
  
  # Verify that source not already recorded
  (not (defined $xh{"$src"})) or
    die "Invalid crossreference table, stopped";
  
  # Store the record
  $xh{"$src"} = \@targets;
}

# We are only interested here in records that take part in the reference
# network, so generate a network hash where the keys are all line
# numbers that are either sources or targets (or both), initializing
# everything to a zero value
#
my %net;
for my $key (keys %xh) {
  # Add source key
  $net{$key} = 0;
  
  # Add target keys
  for my $t (@{$xh{$key}}) {
    $net{$t} = 0;
  }
}

# Now step through all the keys in the network, assigning a group number
# to each
#
my $group_count = 0;
for my $key (keys %net) {
  # If this key already has a group number, we don't need to do anything
  if ($net{$key} > 0) {
    next;
  }
  
  # This key needs a group number, so visit all links from this network
  # node to see if it's connected to anything that already has a group
  # number assigned
  my @scan = group_search(\%xh, \%net, $key, 0);
  
  # If result has more than one group, then merge all groups after the
  # first into the first group since this node is a connection between
  # all the groups
  for(my $i = 1; $i <= $#scan; $i++) {
    group_merge(\%net, $scan[0], $scan[$i]);
  }
  
  # Determine the group ID, which is either the first element of the
  # scan result if that was not empty, or else a brand-new group ID
  my $group;
  if ($#scan >= 0) {
    $group = $scan[0];
  } else {
    $group_count++;
    $group = $group_count;
  }
  
  # Set this node and everything connected to the new group number
  group_set(\%xh, \%net, $key, 0, $group);
}

# Now build the group hash that maps group numbers to array references
# containing all record line numbers within the group
#
my %gl;
for my $key (keys %net) {
  if (defined $gl{$net{$key}}) {
    push @{$gl{$net{$key}}}, ( int($key) );
  } else {
    $gl{$net{$key}} = [ int($key) ];
  }
}

# Within each group, assign each entry a weight based on how many times
# you can reach that node from within the group, and then sort each
# group so that weightiest entries are first
#
for my $key (keys %gl) {
  # If only one element in this group, skip it
  if (scalar(@{$gl{$key}}) < 2) {
    next;
  }
  
  # Create a weight map with everything initialized to zero
  my @wm = map { 0 } @{$gl{$key}};
  
  # Add one weight unit to each element, recursively also adding weight
  # to connections to build the weight map
  for(my $i = 0; $i <= $#wm; $i++) {
    group_weight(\%xh, $gl{$key}, \@wm, $i, 0);
  }
  
  # Build a sorting list where each element is a subarray that has the
  # first element as the weight and the second as the line number of the
  # record
  my @sl;
  for(my $i = 0; $i <= $#wm; $i++) {
    push @sl, ([
      $wm[$i],
      $gl{$key}->[$i]
    ]);
  }
  
  # Sort in descending order of weight
  my @rs = sort { int($b->[0]) <=> int($a->[0]) } @sl;
  
  # Alter current list to the sorted order
  for(my $i = 0; $i <= $#wm; $i++) {
    $gl{$key}->[$i] = $rs[$i]->[1];
  }
}

# Copy group list to another hash that uses the first element of the
# sorted list as the key
#
my %rlh;
for my $key (keys %gl) {
  $rlh{"$gl{$key}->[0]"} = $gl{$key};
}

# Go through final group list in ascending order of the main element and
# print each
#
for my $key (sort { int($a) <=> int($b) } keys %rlh) {
  my $first = 1;
  for my $val (@{$rlh{$key}}) {
    if ($first) {
      $first = 0;
    } else {
      print ' ';
    }
    print "$val";
  }
  print "\n";
}

# @@TODO:


=head1 AUTHOR

Noah Johnson, C<noah.johnson@loupmail.com>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2022 Multimedia Data Technology Inc.

MIT License:

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files
(the "Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

=cut
